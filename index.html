<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plant Clouds</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #111;
      font-family: sans-serif;
      color: #fff;
    }
    #gallery {
      display: grid;
      gap: 1px;
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      grid-auto-rows: 1fr;
    }
    .tile {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      border-radius: 80px;
      cursor: pointer;
    }
    /* SVG hover border overlay */
    .hover-border {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }
    .hover-border rect {
      fill: none;
      stroke: #fff;
      stroke-width: 4px;           /* larger dots */
      stroke-linecap: round;
      stroke-dasharray: 0 12px;     /* more dots around edge */
      stroke-opacity: 0;
      vector-effect: non-scaling-stroke;
    }
    .tile:hover .hover-border rect {
      stroke-opacity: 1;
      animation: dash 0.2s linear infinite;
    }
    @keyframes dash {
      to { stroke-dashoffset: -8; }
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      display: block;
      z-index: 1;
    }
  </style>


  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-34PMHXJY8R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-34PMHXJY8R');
</script>



</head>
<body>
  <div id="gallery"></div>

  <script type="module">
  import * as THREE from 'https://esm.sh/three@0.150.1';
  import { PLYLoader } from 'https://esm.sh/three@0.150.1/examples/jsm/loaders/PLYLoader.js';

  const gallery = document.getElementById('gallery');
  gallery.innerHTML = '';

  // Force fixed 2x2-per-screen grid + scroll
  document.documentElement.style.height = 'auto';
  document.body.style.height = 'auto';
  document.body.style.overflowY = 'auto';

  gallery.style.display = 'grid';
  gallery.style.gridTemplateColumns = 'repeat(2, 1fr)';
  gallery.style.gridAutoRows = '50vh';
  gallery.style.height = 'auto';
  gallery.style.width = '100vw';

  const defaultFiles = [
    'modelA.ply','modelB.ply','modelC.ply',
    'modelD.ply','modelE.ply','modelF.ply',
    'modelG.ply','modelH.ply','modelI.ply','modelJ.ply'
  ];

  // -----------------------------
  // Concurrency-limited load queue
  // -----------------------------
  const MAX_CONCURRENT_LOADS = 2;
  let activeLoads = 0;

  const queuedCanvases = new Set();
  const queue = [];

  function enqueueLoad(tile, canvas, fileName) {
    if (canvas.dataset.loaded || canvas.dataset.enqueued) return;

    canvas.dataset.enqueued = '1';

    if (!queuedCanvases.has(canvas)) {
      queuedCanvases.add(canvas);
      queue.push({ tile, canvas, fileName });
      pumpQueue();
    }
  }

  function pumpQueue() {
    while (activeLoads < MAX_CONCURRENT_LOADS && queue.length > 0) {
      const { tile, canvas, fileName } = queue.shift();
      queuedCanvases.delete(canvas);

      if (canvas.dataset.loaded) continue;

      activeLoads++;
      initTilePreview(tile, canvas, fileName, () => {
        activeLoads--;
        pumpQueue();
      });
    }
  }

  // -----------------------------
  // Lazy enqueue
  // -----------------------------
  const io = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;

        const tile = entry.target;
        const canvas = tile.querySelector('canvas');
        enqueueLoad(tile, canvas, tile.dataset.file);

        io.unobserve(tile);
      }
    },
    {
      root: null,
      rootMargin: '80px 0px 80px 0px',
      threshold: 0.01,
    }
  );

  fetch('./models/models.json')
    .then(res => res.ok ? res.json() : Promise.reject())
    .catch(() => defaultFiles)
    .then(files => {
      files.forEach(fileName => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.file = fileName;
        tile.style.background = '#000';

        tile.onclick = () =>
          window.location.href = `viewer.html?ply=${encodeURIComponent(fileName)}`;

        // SVG border overlay
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.classList.add('hover-border');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        const rect = document.createElementNS(svgNS, 'rect');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');
        rect.setAttribute('width', '100%');
        rect.setAttribute('height', '100%');
        rect.setAttribute('rx', '80');
        rect.setAttribute('ry', '80');
        svg.appendChild(rect);

        // Canvas FIRST
        const canvas = document.createElement('canvas');

        // Loader LAST (always on top)
        const loaderOverlay = document.createElement('div');
        loaderOverlay.className = 'ply-loader';
        loaderOverlay.innerHTML = `
          <div class="dot-track">
            <span></span><span></span><span></span><span></span>
          </div>
        `;

        tile.appendChild(svg);
        tile.appendChild(canvas);
        tile.appendChild(loaderOverlay);

        gallery.appendChild(tile);
        io.observe(tile);
      });

      injectLoaderCSS();
    });

  function injectLoaderCSS() {
    const style = document.createElement('style');
    style.textContent = `
      .tile {
        position: relative;
        background: #000;
        overflow: hidden;
      }

      .tile canvas{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        display:block;
        z-index: 1;
      }

      .tile .hover-border{
        position:absolute;
        inset:0;
        z-index: 20;
        pointer-events:none;
      }

      /* IMPORTANT: show loader by default, hide ONLY when ready */
      .ply-loader{
        position:absolute;
        inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        pointer-events:none;

        opacity:1;            /* always visible until ready */
        transition: opacity 180ms ease;
        background:#000;      /* black behind dots */
        z-index: 30;          /* above canvas, above almost everything */
      }

      .tile.is-ready .ply-loader{
        opacity:0;
      }

      .dot-track{
        display:flex;
        gap:10px;
      }

      .dot-track span{
        width:8px;
        height:8px;
        border-radius:50%;
        background:#fff;
        opacity:0.25;
        animation: dotPulse 1.1s infinite ease-in-out;
      }

      .dot-track span:nth-child(1){ animation-delay: 0s; }
      .dot-track span:nth-child(2){ animation-delay: .12s; }
      .dot-track span:nth-child(3){ animation-delay: .24s; }
      .dot-track span:nth-child(4){ animation-delay: .36s; }

      @keyframes dotPulse{
        0%   { opacity:.25; transform:translateY(0) scale(1); }
        30%  { opacity:1;  transform:translateY(-4px) scale(1.25); }
        60%  { opacity:.35; transform:translateY(0) scale(1); }
        100% { opacity:.25; transform:translateY(0) scale(1); }
      }
    `;
    document.head.appendChild(style);
  }

  function initTilePreview(tile, canvas, file, done) {
    canvas.dataset.loaded = '1';

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      50,
      Math.max(1, canvas.clientWidth) / Math.max(1, canvas.clientHeight),
      0.1,
      100
    );

    renderer.setSize(Math.max(1, canvas.clientWidth), Math.max(1, canvas.clientHeight), false);

    const ro = new ResizeObserver(entries => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width <= 0 || height <= 0) return;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height, false);
      }
    });
    ro.observe(canvas);

    const loader = new PLYLoader();

    let finished = false;
    function finishOnce() {
      if (finished) return;
      finished = true;
      done?.();
    }

    loader.load(
      `models/${file}`,
      geometry => {
        geometry.computeVertexNormals();
        if (!geometry.boundingSphere) geometry.computeBoundingSphere();

        if (!geometry.getAttribute('color')) {
          const c = geometry.getAttribute('position').count;
          const cols = new Float32Array(c * 3).fill(1);
          geometry.setAttribute('color', new THREE.BufferAttribute(cols, 3));
        }

        const material = new THREE.PointsMaterial({
          size: 0.02,
          vertexColors: true,
          sizeAttenuation: true,
          color: new THREE.Color(1.5, 1.5, 1.5)
        });

        const points = new THREE.Points(geometry, material);
        points.position.sub(geometry.boundingSphere.center);
        scene.add(points);

        const radius = geometry.boundingSphere.radius || 1;
        camera.position.set(0, 0, radius * 2.0);
        camera.lookAt(0, 0, 0);

        // Hide dots ONLY when this tile is actually ready
        tile.classList.add('is-ready');

        // Free the concurrency slot
        finishOnce();

        function animate() {
          requestAnimationFrame(animate);
          points.rotation.y += 0.002;
          renderer.render(scene, camera);
        }
        animate();
      },
      undefined,
      err => {
        console.error(`Error loading ${file}:`, err);
        // On error, still hide loader so it doesn't spin forever
        tile.classList.add('is-ready');
        finishOnce();
      }
    );
  }
</script>

</body>
</html>
