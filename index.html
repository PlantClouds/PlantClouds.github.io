<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plant Clouds</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #111;
      font-family: sans-serif;
      color: #fff;
    }
    #gallery {
      display: grid;
      gap: 1px;
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      grid-auto-rows: 1fr;
    }
    .tile {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      border-radius: 80px;
      cursor: pointer;
    }
    /* SVG hover border overlay */
    .hover-border {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }
    .hover-border rect {
      fill: none;
      stroke: #fff;
      stroke-width: 4px;           /* larger dots */
      stroke-linecap: round;
      stroke-dasharray: 0 12px;     /* more dots around edge */
      stroke-opacity: 0;
      vector-effect: non-scaling-stroke;
    }
    .tile:hover .hover-border rect {
      stroke-opacity: 1;
      animation: dash 0.2s linear infinite;
    }
    @keyframes dash {
      to { stroke-dashoffset: -8; }
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      display: block;
      z-index: 1;
    }
  </style>


  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-34PMHXJY8R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-34PMHXJY8R');
</script>



</head>
<body>
  <div id="gallery"></div>

  <script type="module">
  import * as THREE from 'https://esm.sh/three@0.150.1';
  import { PLYLoader } from 'https://esm.sh/three@0.150.1/examples/jsm/loaders/PLYLoader.js';

  const gallery = document.getElementById('gallery');
  gallery.innerHTML = '';

  // Force fixed 2x2-per-screen grid + scroll
  document.documentElement.style.height = 'auto';
  document.body.style.height = 'auto';
  document.body.style.overflowY = 'auto';

  gallery.style.display = 'grid';
  gallery.style.gridTemplateColumns = 'repeat(2, 1fr)';
  gallery.style.gridAutoRows = '50vh'; // 2 rows per viewport
  gallery.style.height = 'auto';
  gallery.style.width = '100vw';

  const defaultFiles = [
    'modelA.ply','modelB.ply','modelC.ply',
    'modelD.ply','modelE.ply','modelF.ply',
    'modelG.ply','modelH.ply','modelI.ply','modelJ.ply'
  ];

  // -----------------------------
  // Concurrency-limited load queue
  // -----------------------------
  const MAX_CONCURRENT_LOADS = 2;
  let activeLoads = 0;

  // Use a Set + Array to avoid duplicates and preserve order
  const queuedCanvases = new Set();
  const queue = [];

  function enqueueLoad(canvas, fileName) {
    if (canvas.dataset.loaded || canvas.dataset.enqueued) return;

    canvas.dataset.enqueued = '1';

    // Keep only one entry per canvas
    if (!queuedCanvases.has(canvas)) {
      queuedCanvases.add(canvas);
      queue.push({ canvas, fileName });
      pumpQueue();
    }
  }

  function pumpQueue() {
    while (activeLoads < MAX_CONCURRENT_LOADS && queue.length > 0) {
      const { canvas, fileName } = queue.shift();
      queuedCanvases.delete(canvas);

      // In case it got loaded by something else
      if (canvas.dataset.loaded) continue;

      activeLoads++;
      initTilePreview(canvas, fileName, () => {
        activeLoads--;
        pumpQueue();
      });
    }
  }

  // --- Lazy enqueue with IntersectionObserver ---
  const io = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;

        const tile = entry.target;
        const canvas = tile.querySelector('canvas');
        const fileName = tile.dataset.file;

        enqueueLoad(canvas, fileName);

        // Once it has been queued, stop observing so we don't enqueue repeatedly
        io.unobserve(tile);
      }
    },
    {
      root: null,
      rootMargin: '250px 0px 250px 0px', // preload a bit
      threshold: 0.01,
    }
  );

  fetch('./models/models.json')
    .then(res => res.ok ? res.json() : Promise.reject('Manifest not found'))
    .catch(() => defaultFiles)
    .then(files => {
      files.forEach(fileName => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.file = fileName;
        tile.onclick = () =>
          window.location.href = `viewer.html?ply=${encodeURIComponent(fileName)}`;

        // SVG border overlay matching your CSS radius
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.classList.add('hover-border');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');

        const rect = document.createElementNS(svgNS, 'rect');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');
        rect.setAttribute('width', '100%');
        rect.setAttribute('height', '100%');
        rect.setAttribute('rx', '80');
        rect.setAttribute('ry', '80');
        svg.appendChild(rect);

        tile.appendChild(svg);

        // Canvas preview (loaded lazily / queued)
        const canvas = document.createElement('canvas');
        tile.appendChild(canvas);

        gallery.appendChild(tile);

        // Observe for lazy enqueue
        io.observe(tile);
      });
    });

  function initTilePreview(canvas, file, done) {
    // Mark as loaded early so we don't double-load if something weird happens
    canvas.dataset.loaded = '1';

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      50,
      Math.max(1, canvas.clientWidth) / Math.max(1, canvas.clientHeight),
      0.1,
      100
    );

    renderer.setSize(Math.max(1, canvas.clientWidth), Math.max(1, canvas.clientHeight));

    const ro = new ResizeObserver(entries => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width <= 0 || height <= 0) return;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }
    });
    ro.observe(canvas);

    const loader = new PLYLoader();

    let finished = false;
    function finishOnce() {
      if (finished) return;
      finished = true;
      done?.();
    }

    loader.load(
      `models/${file}`,
      geometry => {
        geometry.computeVertexNormals();

        if (!geometry.getAttribute('color')) {
          const c = geometry.getAttribute('position').count;
          const cols = new Float32Array(c * 3).fill(1);
          geometry.setAttribute('color', new THREE.BufferAttribute(cols, 3));
        }

        const material = new THREE.PointsMaterial({
          size: 0.02,
          vertexColors: true,
          sizeAttenuation: true,
          color: new THREE.Color(1.5, 1.5, 1.5)
        });

        const points = new THREE.Points(geometry, material);

        // Center model
        if (geometry.boundingSphere == null) geometry.computeBoundingSphere();
        const center = geometry.boundingSphere ? geometry.boundingSphere.center : new THREE.Vector3();
        points.position.sub(center);

        scene.add(points);

        const radius = geometry.boundingSphere ? geometry.boundingSphere.radius : 1;
        camera.position.set(0, 0, radius * 2.0);
        camera.lookAt(0, 0, 0);

        // Release the queue slot as soon as the model is ready (we don't gate animation)
        finishOnce();

        function animate() {
          requestAnimationFrame(animate);
          points.rotation.y += 0.002;
          renderer.render(scene, camera);
        }
        animate();
      },
      undefined,
      err => {
        console.error(`Error loading ${file}:`, err);
        finishOnce();
      }
    );
  }
</script>


</body>
</html>
