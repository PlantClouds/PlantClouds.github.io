<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plant Clouds</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #111;
      font-family: sans-serif;
      color: #fff;
    }
    #gallery {
      display: grid;
      gap: 1px;
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      grid-auto-rows: 1fr;
    }
    .tile {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      border-radius: 80px;
      cursor: pointer;
    }
    /* SVG hover border overlay */
    .hover-border {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }
    .hover-border rect {
      fill: none;
      stroke: #fff;
      stroke-width: 4px;           /* larger dots */
      stroke-linecap: round;
      stroke-dasharray: 0 12px;     /* more dots around edge */
      stroke-opacity: 0;
      vector-effect: non-scaling-stroke;
    }
    .tile:hover .hover-border rect {
      stroke-opacity: 1;
      animation: dash 0.2s linear infinite;
    }
    @keyframes dash {
      to { stroke-dashoffset: -8; }
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      display: block;
      z-index: 1;
    }
  </style>


  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-34PMHXJY8R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-34PMHXJY8R');
</script>



</head>
<body>
  <div id="gallery"></div>

  <script type="module">
  import * as THREE from 'https://esm.sh/three@0.150.1';
  import { PLYLoader } from 'https://esm.sh/three@0.150.1/examples/jsm/loaders/PLYLoader.js';

  const gallery = document.getElementById('gallery');
  gallery.innerHTML = '';

  const defaultFiles = [
    'modelA.ply', 'modelB.ply', 'modelC.ply',
    'modelD.ply', 'modelE.ply', 'modelF.ply',
    'modelG.ply', 'modelH.ply', 'modelI.ply'
  ];

  fetch('./models/models.json')
    .then(res => res.ok ? res.json() : Promise.reject('Manifest not found'))
    .catch(() => defaultFiles)
    .then(files => {
      const count = files.length;
      const cols = Math.ceil(Math.sqrt(count));
      const rows = Math.ceil(count / cols);

      gallery.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      gallery.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

      files.forEach(fileName => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.onclick = () => window.location.href = `viewer.html?ply=${encodeURIComponent(fileName)}`;

        // SVG border overlay matching CSS radius
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.classList.add('hover-border');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');

        const rect = document.createElementNS(svgNS, 'rect');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');
        rect.setAttribute('width', '100%');
        rect.setAttribute('height', '100%');
        rect.setAttribute('rx', '80');
        rect.setAttribute('ry', '80');

        svg.appendChild(rect);
        tile.appendChild(svg);

        // preview canvas
        const canvas = document.createElement('canvas');
        tile.appendChild(canvas);

        gallery.appendChild(tile);

        // ✅ Hover-only animation preview
        initTilePreview(canvas, fileName, tile);
      });
    });

  function initTilePreview(canvas, file, tile) {
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      powerPreference: "low-power"
    });

    // Keep previews cheaper on GPU
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);

    const ro = new ResizeObserver(entries => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        const w = Math.max(1, Math.floor(width));
        const h = Math.max(1, Math.floor(height));
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);
        // If loaded but not animating, keep a crisp still
        if (state.loaded && !state.animating) renderOnce();
      }
    });
    ro.observe(canvas);

    const loader = new PLYLoader();

    const state = {
      loaded: false,
      animating: false,
      rafId: 0,
      points: null
    };

    function renderOnce() {
      if (!state.loaded || !state.points) return;
      renderer.render(scene, camera);
    }

    function animate() {
      if (!state.animating || !state.points) return;
      state.rafId = requestAnimationFrame(animate);
      state.points.rotation.y += 0.002;
      renderer.render(scene, camera);
    }

    function start() {
      if (!state.loaded || state.animating) return;
      state.animating = true;
      animate();
    }

    function stop() {
      state.animating = false;
      if (state.rafId) cancelAnimationFrame(state.rafId);
      state.rafId = 0;
      // leave last frame visible
    }

    // Start/stop only on hover
    tile.addEventListener('pointerenter', start);
    tile.addEventListener('pointerleave', stop);

    // If user switches tabs while animating, stop (saves CPU/GPU)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stop();
    });

    loader.load(
      `models/${file}`,
      geometry => {
        geometry.computeBoundingSphere();
        geometry.computeVertexNormals();

        // Ensure vertex colors exist
        if (!geometry.getAttribute('color')) {
          const c = geometry.getAttribute('position').count;
          const cols = new Float32Array(c * 3).fill(1);
          geometry.setAttribute('color', new THREE.BufferAttribute(cols, 3));
        }

        const material = new THREE.PointsMaterial({
          size: 0.02,
          vertexColors: true,
          sizeAttenuation: true,
          color: new THREE.Color(1.5, 1.5, 1.5)
        });

        state.points = new THREE.Points(geometry, material);

        const center = geometry.boundingSphere ? geometry.boundingSphere.center : new THREE.Vector3();
        state.points.position.sub(center);
        scene.add(state.points);

        const radius = geometry.boundingSphere ? geometry.boundingSphere.radius : 1;
        camera.position.set(0, 0, radius * 2.0);
        camera.lookAt(0, 0, 0);

        // Ensure initial sizing is correct
        const w = Math.max(1, canvas.clientWidth);
        const h = Math.max(1, canvas.clientHeight);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);

        state.loaded = true;

        // ✅ Render ONE still frame on load
        renderOnce();
      },
      undefined,
      err => console.error(`Error loading ${file}:`, err)
    );
  }
</script>

</body>
</html>
